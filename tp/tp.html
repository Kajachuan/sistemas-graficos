<!doctype html>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
<html>
  <head>
    <title>TP Sistemas Gráficos</title>
    <style>
      body{ background-color: grey; }
      canvas{ background-color: white; }
      textarea{ background-color: black; foreground-color: white;}
    </style>

    <script type="text/javascript" src="gl-matrix.js"> // Librería GL-MATRIX </script>

    <!--
    Vertex shader

    El vertex shader define la posición y forma de cada vertice de cada polígono.
    -->
    <script id="shader-vs" type="x-shader/x-vertex">
      // Los atributos son características propias de cada vertice.
      attribute vec3 aVertexPosition;
      attribute vec3 aVertexColor;

      // Los uniforms son características propias de una etapa de dibujado completa.
      // Son comunes a todos los vertices involucrados en el dibujado.
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      // Los varying son propiedades que toman valor para cada fragmento a partir
      // de interpolar linealmente entre los valores que se les asigna en cada
      // vértice del polígono al cual pertenecen.
      varying highp vec4 vColor;

      void main(void) {
        // gl_Position es una variable "built-in" de GLSL que es usada para
        // almacenar la posición resultante del fragmento.
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = vec4(aVertexColor,1.0);
      }
    </script>

    <!--
    Fragment shader

    Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
    establecer el color de cada pixel. En este caso, asignamos el color blanco a
    cada pixel.
    -->
    <script id="shader-fs" type="x-shader/x-fragment">
      varying highp vec4 vColor;

      void main(void) {
        // gl_FragColor es una variable "built-in" de GLSL que es usada para
        // almacenar el color resultante del fragmento.
        gl_FragColor = vColor;
      }
    </script>

    <!-- <script>
      var gl = null,
      canvas = null,
      glProgram = null,
      fragmentShader = null,
      vertexShader = null,
      t = 0.0;
      my_grid = null;

      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();


      // SHADERS FUNCTION
      function getShader(gl, id) {
        var shaderScript, src, currentChild, shader;

        // Obtenemos el elemento <script> que contiene el código fuente del shader.
        shaderScript = document.getElementById(id);
        if (!shaderScript) {
          return null;
        }

        // Extraemos el contenido de texto del <script>.
        src = "";
        currentChild = shaderScript.firstChild;
        while(currentChild) {
          if (currentChild.nodeType == currentChild.TEXT_NODE) {
            src += currentChild.textContent;
          }
          currentChild = currentChild.nextSibling;
        }

        // Creamos un shader WebGL según el atributo type del <script>.
        if (shaderScript.type == "x-shader/x-fragment") {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
          shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
          return null;
        }

        // Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
        gl.shaderSource(shader, src);

        // Compilamos el shader.
        gl.compileShader(shader);

        // Chequeamos y reportamos si hubo algún error.
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert("An error occurred compiling the shaders: " +
          gl.getShaderInfoLog(shader));
          return null;
        }

        return shader;
      }




      //////////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////////
      //
      // OBJETO VERTEX-GRID
      // Definimos un constructor para el objeto VertexGrid
      function VertexGrid (_rows, _cols) {
        this.cols = _cols;
        this.rows = _rows;
        this.index_buffer = null;

        this.position_buffer = null;
        this.color_buffer = null;

        this.webgl_position_buffer = null;
        this.webgl_color_buffer = null;
        this.webgl_index_buffer = null;

        this.createIndexBuffer = function() {

          // Se genera el index buffer a partir de cols y rows
          this.index_buffer = [];
          for (var i = 1.0; i < this.rows; i++) {
            if (i == 1.0)
              this.index_buffer.push(0);
            else
              this.index_buffer.push(this.index_buffer[this.index_buffer.length - 1]);

            for (var j = 1.0; j < this.cols * 2; j++) {
              if (j % 2.0 == 1.0)
                this.index_buffer.push(this.index_buffer[this.index_buffer.length - 1] + this.cols);
              else {
                if (i % 2.0 == 1.0)
                  this.index_buffer.push(this.index_buffer[this.index_buffer.length - 1] - (this.cols - 1));
                else
                  this.index_buffer.push(this.index_buffer[this.index_buffer.length - 1] - (this.cols + 1));
              }
            }
          }
        }

        // Esta función inicializa el position_buffer y el color buffer de forma de
        // crear un plano de color gris que se extiende sobre el plano XY, con Z=0
        // El plano se genera centrado en el origen.
        // El propósito de esta función es a modo de ejemplo de como inicializar y cargar
        // los buffers de las posiciones y el color para cada vértice.
        this.createUniformPlaneGrid = function() {

          this.position_buffer = [];
          this.color_buffer = [];

          t = (2.0 * Math.PI) / (this.cols - 1)

          for (var i = 0.0; i < this.rows; i++) {
            for (var j = 0.0; j < this.cols; j++) {

              // Para cada vértice definimos su posición
              // como coordenada (x, y, z=0)
              // this.position_buffer.push(i-(this.rows-1.0)/2.0);
              // this.position_buffer.push(j-(this.rows-1.0)/2.0);
              // this.position_buffer.push(0);
              // ESTO GENERA UN PLANO

              this.position_buffer.push(Math.cos(j * t));
              this.position_buffer.push(i - this.rows / 2);
              this.position_buffer.push(Math.sin(j * t));

              // Para cada vértice definimos su color
              this.color_buffer.push(1.0/this.rows * i);
              this.color_buffer.push(0.2);
              this.color_buffer.push(1.0/this.cols * j);

            };
          };
        }

        // CREAR RUEDA
        this.crearRueda = function() {
          this.position_buffer = [];
          this.color_buffer = [];

          ang = Math.PI / (this.cols - 1);

          for (var i = 0.0; i < this.rows; i++) {
            x = 0.0
            y = 0.0
            b = i <= 1 ? 1 : 0;
            g = i <= 1 ? 0 : 1;
            for (var j = 0.0; j < this.cols; j++) {
              if (i == 0) {
                x = Math.cos(j * ang);
                y = Math.sin(j * ang);
              }

              else if (i == 3) {
                x = Math.cos(j * ang);
                y = -Math.sin(j * ang);
              }

              this.position_buffer.push(2 * x);
              this.position_buffer.push(2 * y);
              this.position_buffer.push(0);

              this.color_buffer.push(b * 1.0 + g * 0.67);
              this.color_buffer.push(b * 1.0 + g * 0.67);
              this.color_buffer.push(b * 1.0 + g * 0.67);
            }
          }
        }

        // CREAR BALDE
        this.crearBalde = function() {
          this.position_buffer = [];
          this.color_buffer = [];

          for (var i = 0.0; i < this.rows; i++) {
            for (var j = 0.0; j < this.cols; j++) {
              x = (2 * i - this.rows)/this.rows;
              y = (2 * j - this.rows)/this.rows;

              if(j == 15) {
                x += i * 2 / this.rows;
              }

              this.position_buffer.push(x);
              this.position_buffer.push(y);
              this.position_buffer.push(0);

              this.color_buffer.push(1.0);
              this.color_buffer.push(1.0);
              this.color_buffer.push(1.0);
            }
          }
        }


        // Esta función crea e incializa los buffers dentro del pipeline para luego
        // utlizarlos a la hora de renderizar.
        this.setupWebGLBuffers = function(){

          // 1. Creamos un buffer para las posicioens dentro del pipeline.
          this.webgl_position_buffer = gl.createBuffer();
          // 2. Le decimos a WebGL que las siguientes operaciones que vamos a ser se aplican sobre el buffer que
          // hemos creado.
          gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_position_buffer);
          // 3. Cargamos datos de las posiciones en el buffer.
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.position_buffer), gl.STATIC_DRAW);

          // Repetimos los pasos 1. 2. y 3. para la información del color
          this.webgl_color_buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_color_buffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.color_buffer), gl.STATIC_DRAW);

          // Repetimos los pasos 1. 2. y 3. para la información de los índices
          // Notar que esta vez se usa ELEMENT_ARRAY_BUFFER en lugar de ARRAY_BUFFER.
          // Notar también que se usa un array de enteros en lugar de floats.
          this.webgl_index_buffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.webgl_index_buffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.index_buffer), gl.STATIC_DRAW);
        }


        // Esta función es la que se encarga de configurar todo lo necesario
        // para dibujar el VertexGrid.
        // En el caso del ejemplo puede observarse que la última línea del método
        // indica dibujar triángulos utilizando los índices cargados en el Index_Buffer.
        this.drawVertexGrid = function(){

          var vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
          gl.enableVertexAttribArray(vertexPositionAttribute);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_position_buffer);
          gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

          var vertexColorAttribute = gl.getAttribLocation(glProgram, "aVertexColor");
          gl.enableVertexAttribArray(vertexColorAttribute);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_color_buffer);
          gl.vertexAttribPointer(vertexColorAttribute, 3, gl.FLOAT, false, 0, 0);

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.webgl_index_buffer);

          // Dibujamos.
          gl.drawElements(gl.TRIANGLE_STRIP, this.index_buffer.length, gl.UNSIGNED_SHORT, 0);
        }
      }

      //////////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////////


      function initWebGL() {
        canvas = document.getElementById("my-canvas");
        try {
          gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        } catch(e) {
        }

        if(gl) {
          setupWebGL();
          initShaders();
          setupBuffers();
          setInterval(drawScene, 10);
        } else{
          alert(  "Error: Your browser does not appear to support WebGL.");
        }
      }

      function setupWebGL() {
        //set the clear color
        gl.clearColor(1, 1, 1, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      function initShaders() {
        // Obtenemos los shaders ya compilados
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        // Creamos un programa de shaders de WebGL.
        glProgram = gl.createProgram();

        // Asociamos cada shader compilado al programa.
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);

        // Linkeamos los shaders para generar el programa ejecutable.
        gl.linkProgram(glProgram);

        // Chequeamos y reportamos si hubo alg�n error.
        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
          alert("Unable to initialize the shader program: " +
          gl.getProgramInfoLog(glProgram));
          return null;
        }

        // Le decimos a WebGL que de aqu� en adelante use el programa generado.
        gl.useProgram(glProgram);
      }

      function setupBuffers() {
        my_grid = new VertexGrid(16, 16);
        my_grid.createUniformPlaneGrid();
        my_grid.createIndexBuffer();
        my_grid.setupWebGLBuffers();
      }

      function drawScene() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
        // Preparamos una matriz de perspectiva.
        mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);
        gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

        var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
        // Preparamos una matriz de modelo+vista.
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);
        mat4.rotate(mvMatrix, mvMatrix, t, [0.0, 1.0, 0.0]);
        t = t + 0.01;

        gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);

        my_grid.drawVertexGrid();
      }

    </script> -->
    <script type="text/javascript" src="script.js"></script>
  </head>
  <body onload="initWebGL()">
    <center>
      <h1>Trabajo Práctico - Sistemas Gráficos</h1>
      <h2>Nombre</h2>
      <canvas id="my-canvas" width="900" height="500">
        Your browser does not support the HTML5 canvas element.
      </scanvas>
    </center>
  </body>
</html>
